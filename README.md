# Задача "Понимание JVM"
## Код
```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1 
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

- Вначале наши классы ```JvmComprehension```, ```Object```, ```Integer```, ```System```  
будут подгружены Classloader'ом который делится на 3 уровня

#### Loading  

##### Bootstrap Classloader - классы стандартной библиотеки Java
##### Platform ClassLoader - классы доп библиотек и реализации под конкретную платформу
##### Application ClassLoader - классы уровня приложения

Класс JvmComprehension будет найден на нижнем уровне Application ClassLoader,  
все остальные будут найдены на самом верхнем уровне Bootstrap Classloader  
Загружены классы будут в порядке обращения к ним, чтобы не забивать память

#### Linking  

- проверяет, что код валиден
- подготовка примитивов у нас это ```int i```
- связывание ссылок на другие классы, все классы являются частью стандартной библиотеки,   
этап пройдет без ошибок

#### Initialization

Выполняет статические инициализаторы и инициализаторы статических полей
-   ```public static void main(String[] args)```
-   ```printAll(o, i, ii)``` + его ```"sout"```
-   ```System.out.println("finished")```


#### Runtime Data Area  

 1. Создается фрейм в Stack ```main()```
 2. ```int i = 1``` попадает во фрейм ```main()``` 
 3. Создается объект ```Object o``` в куче, а ссылка на него кладется во фрейм ```main()```
 4. Создается объект ```Integer ii``` в куче, а ссылка на него кладется во фрейм ```main()```
 5. Создается фрейм в Stack ```printAll(o, i, ii)``` там создаются: 
 - ссылка ```o``` на объект в куче ```Object```
 - инициилизируется ```int i = 1``` соглассно переданному значению
 - ссылка ```ii``` на объект в куче ```Object``` 
 7.  Создается объект ```Integer``` в куче, а ссылка на него ```uselessVar``` кладется во фрейм ```main()``` 
 8.  Создается фрейм в Stack ```sout``` со ссылками на кучу и ```int i = 1``` (o.toString() - тоже создает фрейм)  
 9.  После выполнения данные из фрейма начинают удалятся в соответствие с "последний зашел первый вышел", когда фрейм окажется пустым удалится и он сам из Stack'a
 10. Далее после удаления всех фреймов кроме ```main``` в Stack создастся новый фрейм на ```sout()```
 11. Будет создан объект ```String``` в куче, а ссылка будет во фрейме ```sout()```;
 12. После выполнения будет очищен фрем, а после этого удален полностю.
 13. Далее будет зачищен фрейм ```main()```
 14. Stack остался пустым программа завершила свою работу

#### Сборщик мусора
В процессе работы программы работает сборщик мусора, который   
ищет и удаляет объекты из кучи, которые больше не используются.  
Поиск таких объектов происходит с прмрщью обхода графа достижимох объектов.  
Достижимые объекты групируются по поколениям,  
если объект пережил несколько чисток, то его реже проверяют.  
Вовремя сборки мусора все потоки останавливаются(засыпают).
### Куча
(Eden) - (Survivor0) - (Survivor1) - (Tenured)  
(До GC) - (После 1-сборки) - (После 2-сборки) - (остаются с нами навсегда)
